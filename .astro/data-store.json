[["Map",1,2,9,10,26,27],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.16.6","content-config-digest","f15585db1bab9030","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://aravindsanjeev.com\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{\"js\":\"javascript\",\"cjs\":\"javascript\",\"mjs\":\"javascript\"},\"theme\":\"dracula\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[null,null],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false,\"svgo\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12],"a-complete-guide-to-usestate-hook",{"id":11,"data":13,"body":21,"filePath":22,"digest":23,"legacyId":24,"deferredRender":25},{"title":14,"publishedAt":15,"summary":16,"tags":17},"A Complete Guide to React's useState Hook","2025-01-15","The useState hook is used to create and manage local state in functional components.",[18,19,20],"react","javascript","frontend","\u003CCallout type=\"note\">\r\n  This post was originally written back when class components were still all the\r\n  rage. Yes, I repurposed an old markdown file for this blog. So if you're a new\r\n  dev, and you're wondering why I'm even mentioning them, just go with it. We\r\n  all have to start somewhere, right?\r\n\u003C/Callout>\r\n\r\nReact has two types of components - functional & class. Traditionally, only class components were allowed to have state and lifecycle methods. However, that changed with the introduction of hooks in React 16.8.\r\n\r\nNow functional components also have access to state and lifecycle methods. For simple states, we use the `useState` hook and for handling more complex states, we use the `useReducer` hook. For the lifecycle methods, we use the `useEffect` hook.\r\n\r\nIn this article, we will be covering the `useState` hook in an in-depth fashion. The ultimate goal of this article is to hopefully make sure that you don't have to go elsewhere to learn more about `useState`.\r\n\r\n## What are hooks anyway?\r\n\r\nHooks were introduced to React in version 16.8. They are just regular JavaScript functions. Hooks helps us \"hook into\" state and lifecycle methods from functional components.\r\n\r\nThe terminology makes a lot of sense since only class components were allowed to have state or lifecycle methods.\r\n\r\nThis isn't to say that behavior or implementation of hooks is the same as that of `setState` or lifecycle methods in class components. That is far from true - as you will soon see in the case of `useState`.\r\n\r\nFor now, note that that hooks allows us to use state and lifecycle methods in functional components. That was ultimately the purpose of class components making class components a legacy feature in react.\r\n\r\nHooks take advantage of something called the _fiber architecture_ in React. This article won't cover fiber architecture in much detail. However, we will be looking specific cases for `useState`.\r\n\r\n## The useState hook\r\n\r\nToday, we will specifically be talking about the `useState` hook. The `useState` hook allows us to have simple state in functional components.\r\n\r\nIt is a named export from the React library meaning we can import it as follows:\r\n\r\n```js\r\nimport React, { useState } from \"react\";\r\n```\r\n\r\nOr you can simply just use the `.` operator:\r\n\r\n```js\r\nimport React from \"react\";\r\n\r\nReact.useState(); // also works\r\n```\r\n\r\nThe `useState` hook takes 1 argument which is the initial state and returns an array. The array contains 2 elements which is the state variable and the setter function.\r\n\r\nSo if we were to take a look at the basic structure of the `useState` hook, it will be something like this:\r\n\r\n```js\r\nexport function useState(initialState) {\r\n  // logic\r\n  return [state, setState];\r\n}\r\n```\r\n\r\nOn the initial render, the `state` will be same as the `initialState`. However, `initialState` is ignored after first render. Hence, state variable will always be returning the _current state_.\r\n\r\nIf there is no initial state, then state variable will return `undefined` on the first render.\r\n\r\nThe setter function (`setState`) is used to change the value of the state.\r\n\r\n## Basic usage\r\n\r\nFirst we import `useSate` from React.\r\n\r\n```js\r\nimport React, { useState } from \"react\";\r\n```\r\n\r\nThen we simply use array destructuring to access the state variable and setter function while passing intial state as an argument to the `useState` hook.\r\n\r\n```js\r\n// ..\r\n\r\nfunction Counter() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return \u003Cp>{count}\u003C/p>;\r\n}\r\n\r\n// renders 0 in the UI\r\n```\r\n\r\nPS: At this point, we can also lazy initialize the initial state. We'll talk more about that down the road.\r\n\r\nIt is possible to use array index as well.\r\n\r\n```js\r\n//..\r\nconst count = useState(0)[0];\r\nconst setCount = useState(0)[1];\r\n//..\r\n```\r\n\r\nAlthough this works fine, it is obviously inconvenient.\r\n\r\nRight now, you might be thinking why the `useState` just doesn't return an object instead. That's because we will have to go through extra syntax to change the variable names.\r\n\r\n```js\r\n// if useState returned an object\r\nconst { state: count, setState: setCount } = useState(0);\r\n```\r\n\r\nHowever, it makes sense to return objects if there are large return values. That is because we can selectively destructure object properties. There are third-party libraries that has hooks which utilize this feature. But react's default hooks return only few values making it unnecessary.\r\n\r\n## Updating the state\r\n\r\nTo update the state, we use the setter function that is returned by the `useState` hook. In the above example, it is the `setCount` function.\r\n\r\n```js\r\nsetCount(1);\r\n```\r\n\r\nWhen this function is executed, we update the state variable with value 1. _Technically, a new state variable is created with the value 1_. We will talk more about that later. For now, using the setter function like above is not necessarily very useful.\r\n\r\nNormally, we will use the setter function inside a click handler, the `useEffect` hook, or directly inside the `onClick` attribute.\r\n\r\n```js\r\n//..\r\nreturn (\r\n  \u003C>\r\n  \u003Cp>{count}\u003Cp>\r\n  \u003Cbutton onClick={() => setCount(count + 1)}>Increment\u003C/button>\r\n  \u003C/>\r\n)\r\n// increments by 1 on every click\r\n```\r\n\r\nNow when we click the button, the `count` variable increments by 1. However, it is important to note that setter functions are actually asynchronous. So when we click the button, we are just adding the update to a queue. It is not executed immediately. This is has to do with the fiber architecture of react.\r\n\r\nRight now, we have gone through most basic use of the `useState` hook. We have,\r\n\r\n- Imported it\r\n- Passed initial state\r\n- Destructred the state and setter function\r\n- Used the setter function to update the state\r\n\r\nPS: We have for now only passed a number as the state. We can really pass anything. We will be taking a look at each specific case soon. For now, let's take a look at two advanced `useState` patterns. Understanding them would complement rest of the article's contents.\r\n\r\n## Advanced useState patterns\r\n\r\n### 1. Lazy initialization\r\n\r\nEarlier I mentioned that we can lazily initialize a state. What lazy initialization means is that we will be assigning the state value only when we need it. That means the state value won't be passed to the state variable when react first renders.\r\n\r\nYou might be thinking why that is even necessary. Well, if the state value is a result of some strong computation, for example, a parsed JSON coming from an API call. In that case, you don't want the UI to freeze until that computation is complete and state is initialized. Needless to say, that will be bad user experience.\r\n\r\nSo what you do is in fact lazily initialze the state. That's very simple, all you have to do is to pass the state inside the return value of a function.\r\n\r\n```js\r\n//..\r\nconst [count, setCount] = useState(() => 0);\r\n//..\r\n```\r\n\r\nIn the above case, the function is the one that is passed as initial state to the `useState` hook. The `useState` hook is defined in such a way that if a function is passed, then it will execute and assign the return value to the state variable. What it won't do is keep the `useState` process alive until the computation is complete. So it make sures that UI is rendered regardless of whether the state was initialized.\r\n\r\nYou can also define a function outside and just pass it to the useState like so.\r\n\r\n```js\r\nfunction computation() {\r\n  // hard hitting computation\r\n}\r\n\r\n//..\r\nconst [state, setState] = useState(() => computation());\r\n//..\r\n```\r\n\r\nHere the `computation()` function is run as needed and won't block the UI rendering.\r\n\r\n### 2. Using previous state to update current state\r\n\r\nLet's revisit the above example.\r\n\r\n```js\r\nconst React, {useState} from 'react';\r\n\r\nfunction Counter() {\r\n  const [count, setCount] = useState(0)\r\n}\r\n\r\nreturn (\r\n  \u003C>\r\n  \u003Cp>{count}\u003C/p>\r\n  \u003Cbutton onClick={() => setCount(count + 1)}>Increment\u003C/button>\r\n  \u003C/>\r\n)\r\n```\r\n\r\nHere we are directly passing the state variable and adding 1 inside the `setCount()`. Problem with this approach is that we cannot do a second update with the updated value. For example,\r\n\r\n```js\r\nfunction Counter() {\r\n  const [count, setCount] = useState(0);\r\n}\r\n\r\nfunction handleClick() {\r\n  setCount(count + 1); // returns 0 + 1 = 1\r\n  setCount(count + 2); // returns 0 + 2 = 2\r\n}\r\n\r\nreturn (\r\n  \u003C>\r\n    \u003Cp>{count}\u003C/p>\r\n    \u003Cbutton onClick={() => handleClick()}>Increment by 3\u003C/button>\r\n  \u003C/>\r\n);\r\n\r\n// final state value will be 2 not 3\r\n```\r\n\r\nIn the above case, you would think that at first `count` will be 1, then it will add 2 to become 3. Then you're thinking wrong.\r\n\r\nReact only _really_ updates the state variable after a UI update. React has two phases when a component updates:\r\n\r\n1. The render phase\r\n2. The commit phase\r\n\r\nIn the commit phase, the UI is actually updated. But during the render phase, the component has to be in the same state. Meaning if you call multiple setter functions, all the setter functions will be initialized with the same state.\r\n\r\nIn the above case, both `setCount`s were initialized with 0 and added to the queue. Because JavaScript takes the last value as the final, the state value was 2.\r\n\r\nNow react team obviously knows this is going to be a problem. Because we definitely want to be able to use updated values in the same rendering phase at some point.\r\n\r\nThe solution here is very similar to lazy initialization. We just pass arrow functions instead. The arrow functions accepts 1 argument which will be the previous state.\r\n\r\n```js\r\n//..\r\nfunction handleClick() {\r\n  setCount((prevCount) => prevCount + 1); // returns 0 + 1 = 1\r\n  setCount((prevCount) => prevCount + 2); // returns 1 + 2 = 3\r\n}\r\n//..\r\n```\r\n\r\nThis works because we are passing a function and the setter function is defined in such a way that if it encounters a function as an argument, then it will automatically pass the previous state as the first argument of that function.\r\n\r\nSo both the `useState()` hook and the setter function has specific check to see if the value passed is a function. Otherwise, they work as normal giving as the above 2 patterns.\r\n\r\n## Using useState with primitive data types\r\n\r\nWe already used the `useState` with a primitive data type - number. But really, you can also use other primitive data types like boolean or string.\r\n\r\n```js\r\n//..\r\nconst [isLoggedIn, setIsLoggedIn] = useState(false); // using boolean\r\nconst [name, setName] = useState(\"Elon Musk\"); // using string\r\n//..\r\n```\r\n\r\nIt is important to understand that when we change the value of `isLoggedIn` or `name`, we are actually creating a new variable with that value. That's just how JavaScript works. This is not relevant for primitive data types but will be relevant for arrays and objects as you will soon see.\r\n\r\nIt is also important to make sure that you update the state variable using `setIsLoggedIn` or `setName` function. Otherwise, the react library won't know the update has taken place. You'll still update the value, but rendering won't take place.\r\n\r\n```js\r\nisLoggedIn = true;\r\nconsole.log(isLoggedIn); // prints \"true\" in console\r\n\r\n// however, rendering will not take place\r\n// because react doesn't know state variable has changed\r\n\r\n// the right way to do it\r\nsetIsLoggedIn(true);\r\n```\r\n\r\nThe `setIsLoggedIn` function will assign `true` to the state variable, but this time it will also re-render the component. So the entire UI logic is executed again with updated state value.\r\n\r\n## Using useState with arrays\r\n\r\nWe can also have arrays as our state variable.\r\n\r\n```js\r\n//..\r\nconst [list, setList] = useState([\"Apple\", \"Orange\", \"Grape\"]);\r\n//..\r\n```\r\n\r\nNow it is important to keep in mind that we are creating a new array with updated value. So when we do update them, make sure to clone the original array first and then update the new values.\r\n\r\n```js\r\n//..\r\nsetList([...list, \"Banana\"]);\r\n//..\r\n```\r\n\r\nHere the spread operator `...` will clone the contents of the existing array and finally Banana will be added to the end.\r\n\r\nOr you can add Banana at the top by exchanging the position.\r\n\r\n```js\r\n//..\r\nsetList([\"Banana\", ...list]);\r\n//..\r\n```\r\n\r\nIf you want to remove an element, then you have to use regular JavaScript logic to create a new array and then just update the state as follows.\r\n\r\n```js\r\n//..\r\nconst newList = list.filter((item) => item !== \"Grape\"); // or some other logic\r\nsetList([...newList]);\r\n\r\n// list becomes [\"Apple\", \"Orange\", \"Banana\"]\r\n// (Grape is filtered out)\r\n```\r\n\r\nYou can use `pop()`, `splice()`, `shift()` and other methods to remove items from the array. This is where your regular JavaScript skills matter. For example, you might have to deal with objects inside the arrays, etc.\r\n\r\n### Dealing with multidimensional arrays\r\n\r\nMultidimensional arrays are arrays that have other arrays within them. The spread operator only goes one level deep when copying content. So it won't behave as intended with multidimensional arrays. If you find yourself dealing with multidimensional arrays, you're better of trying to redo logic to handle simpler state objects.\r\n\r\nYou can still use array methods like `map()` then create complex logic to deal with them. It's just not ideal.\r\n\r\n## Using useState with objects\r\n\r\nWe can also pass objects as state in the `useState` hook.\r\n\r\n```js\r\n//..\r\nconst [user, setUser] = useState({\r\n  firstName: \"Elon\",\r\n  lastName: \"Musk\",\r\n});\r\n//..\r\n```\r\n\r\nIt is once again important to keep in mind that we will be creating a new object during each state update. So we must clone the original object first and then do the update.\r\n\r\n```js\r\n//..\r\nsetUser({ ...user, age: \"50\" });\r\n//..\r\n```\r\n\r\nPlease not the syntax difference. For arrays, we use the `[]` brackets and for objects, we use `{}`. Well, we are creating a new array/object.\r\n\r\nWe can also update an existing property like so:\r\n\r\n```js\r\n//..\r\nsetUser({ ...user, lastName: \"Dusk\" });\r\n\r\n// user becomes {\r\n// firstName: \"Elon\",\r\n//  lastName: \"Dusk\",\r\n//}\r\n```\r\n\r\n### Dealing with nested objects\r\n\r\nThe same problem persists with the spread operator here as well. The spread operator only goes one level deep. So if we have nested objects, it will not be cloned by spread operator. Imagine the situation:\r\n\r\n```js\r\nconst person = {\r\n  firstName: \"Elon\",\r\n  lastName: \"Musk\",\r\n  childRandom: {\r\n    firstName: \"Griffin\",\r\n    lastName: \"Musk\",\r\n  },\r\n};\r\n\r\nconst [user, setUser] = useState(person);\r\n```\r\n\r\nLet's suppose we have to add age of Griffin Musk. How would you do it? I imagine it would be like this:\r\n\r\n```js\r\n//..\r\nsetUser({...user, childRandom.age = 18}) // wrong\r\n```\r\n\r\nThis doesn't work as spread operator does only shallow copying. Means the `...user` contains only properties that are one level deep. So you have to infact use spread operator again to go deeper.\r\n\r\n```js\r\n//..\r\nsetUser({...user, childRandom: {\r\n  ...user.childRandom, age: 18\r\n}\r\n```\r\n\r\nAs you can see, we used spread operator to create another shallow copy inside `childRandom`. This can get complicated with deeply nested objects. To avoid that, you can just call multiple `useState` hooks.\r\n\r\n```js\r\nconst father = {\r\n  firstName: \"Elon\",\r\n  lastName: \"Musk\",\r\n};\r\n\r\nconst child = {\r\n  firstName: \"Griffin\",\r\n  lastName: \"Musk\",\r\n};\r\n\r\nconst [userOne, setUserOne] = useState(father);\r\nconst [userTwo, setUserTwo] = useState(child);\r\n```\r\n\r\nWhen to use objects or multiple `useState` calls is upto you. But going too deep with nested objects is always a bad idea.\r\n\r\nPS: We can still use the advanced `useState` pattern to use the previous state by passing an arrow function. It works for primitives, arrays, and objects.\r\n\r\n## Using props as initial state\r\n\r\nWe can pass props as the initial state, but don't expect the state to change if the props changes. For example, if we write something like this:\r\n\r\n```js\r\n//..\r\nfunction User(props) {\r\n  const [name, setName] = useState(props.name);\r\n}\r\n```\r\n\r\nHere we are passing a prop as the initial state. If this prop changes after first render, it will not affect `useState` in anyway. The `useState` hook takes the initial value during first render and cares to update only when the setter function is called. So prop changes won't change state.\r\n\r\nIn this case, you can use the `useEffect` hook with that specific prop as a dependency and call the setter function instead.\r\n\r\n```js\r\n//..\r\nfunction User(props) {\r\n  const [name, setName] = useState(props.name);\r\n}\r\n\r\nuseEffect(() => {\r\n  setName(props.name);\r\n}, [props.name]);\r\n```\r\n\r\nIf you don't know `useEffect` hook, it is used to imitate lifecycle methods. It takes 2 arguments,\r\n\r\n1. A function\r\n2. A dependency array\r\n\r\nThe body of the function contains stuff we need to execute and the dependency array determines what changes trigger the `useEffect`.\r\n\r\nA `useEffect` is always run once in the initial render. So technically you need not pass the intial state in the above case. But really it doesn't hurt.\r\n\r\n## Fiber architecture & the updation process\r\n\r\nAs I already mentioned, react (and by implication react hooks) take advantage of something called the fiber architecture. Discussing fiber architecture in detail is beyond the scope of this specific article. But we still need to understand how fiber architecture is utilized with the `useState` hook.\r\n\r\nSo fiber architecture has two phases,\r\n\r\n1. The render phase\r\n2. The commit phase\r\n\r\nWe already discussed this in brief before. The render phase is completely asynchronous. Meaning we can actually start and stop processes inside the render phase. The commit phase is however synchronous and cannot be disturbed.\r\n\r\nThe fiber architecture works in a way that it prioritize certain processes over others. In react, we can call them _work_. So react prioritize certain work over others.\r\n\r\nA _fiber_ is simply a unit of that work. So a fiber could be something like a state update. Really it could be any piece of logic that gets something done.\r\n\r\nWhat you need to keep in mind is that react fiber has a priority list and on top of that is the UI update. That's why commit phase is actually synchronous. Which means it can never or should never be interrupted.\r\n\r\nOn the render phase however, everything works asynchronously. So there is clearly lot of interruptions based on priority.\r\n\r\nAs a result of that, when we update the state using the setter function, what's really happening is that we are adding the updation process to a queue.\r\n\r\nAll state updates are called in order, which is why you must declare them in proper order as well. Because the ones that are declared first are prioritized over the ones that are declared later.\r\n\r\nEach of these state updates end by pointing to the next state update. Hence that actually forms a tree and that tree is executed top to bottom until nothing is being pointed at any more.\r\n\r\nAll these complex logic are abstracted away from us but what it does is something quite wonderful. The fibre architecture not only makes react fast, it also makes it smart.\r\n\r\n**Now coming to the actual updation process..**\r\n\r\nAs I already mentioned, react fiber has 2 phases - the render phase & the commit phase. When the `useState` hook is executed, the whole process goes through both of these phases.\r\n\r\nThe render and commit phase in works like this:\r\n\r\n### The render phase\r\n\r\nIf a `useState` or `useReducer` is present, the state value is initialized.\r\n\r\nThe JSX of the component gets converted to react elements. This is done using the `React.createElement()` method.\r\n\r\nThis in turn creates a component tree. This is simply an object representation of the actual component. We call this the virtual DOM.\r\n\r\n### The commit phase\r\n\r\nIn the commit phase, the real DOM is updated with the values of the virtual DOM.\r\n\r\nThis is all fine if our component only renders once.\r\n\r\nBut interesting things happen when we have a `useState` or `useReducer` in our component. That's because having a state means a component can flag itself for re-renders.\r\n\r\nIn this case, a component is flagged when we run the setter function. (Or dispatch for `useReducer`).\r\n\r\n_**PS:** Re-renders can also happen if there is a change in prop or due to parent re-render. We are only talking about re-renders that happens due to setter functions in `useState`._\r\n\r\nDuring re-renders, the render phase and commit phase acts a bit differently.\r\n\r\nIn the render phase, the state variable is checked to see if there is a change of value.\r\n\r\nIf there is, the `React.createElement()` is called again and JSX is converted to a component tree. This time, the newly created tree is compared to the current tree to see if there are any changes. The changes are applied to the virtual DOM and changes are passed to the commit phase.\r\n\r\nIf the state variable hasn't changed, then react bails out from the rendering process altogether.\r\n\r\nDuring the commit phase, the real DOM is updated as usual. Note that only changes are updated as only changes are passed to the commit phase by react.\r\n\r\n### Safety net\r\n\r\nWhen a component re-renders for the first time and state variable hasn't changed, react will go through the render phase anyway. It will however bail out from the commit phase. This won't happen for subsequent renders.\r\n\r\nThis is just a safety feature employed by react.\r\n\r\n## Rules of react hooks\r\n\r\nOkay, now let's discuss something much simpler. React hooks have certain rules (well, 2) that must be obeyed. The rules are simple,\r\n\r\n1. A hook must be called only on the top-level of the component.\r\n2. A hook must be called only on functional components.\r\n\r\nThe second rule is obvious. We don't need hooks in class components. The entire purpose is to dumb class components altogether.\r\n\r\nHowever for the first one, a hook should be called like this:\r\n\r\n```js\r\nfunction App() {\r\n  const [state, setState] = useState(0); // or any other hook\r\n}\r\n```\r\n\r\nThat means you cannot call a hook inside a condition or other hooks like `useEffect` etc.\r\n\r\nThis is because react has to call those hooks first and in same order before it does anything else. Otherwise, it cannot preserve the state.\r\n\r\n## The useReducer hook and handling complex states\r\n\r\nOkay, I know this is a long article already. But it isn't complete without briefly touching about the `useReducer` hook.\r\n\r\nThe `useReducer` hook also helps us manage state in react. In fact, the `useState` is an abstraction from the `useReducer` hook. Behind the scenes, we are still using `useReducer` with some fixed conditions which makes it behave like `useState`.\r\n\r\nA `useReducer` hook accepts initial state and a reducer function and returns an array. The array has the state variable and dispatch method.\r\n\r\n```js\r\nimport React, { useReducer } from \"react\";\r\n\r\nfunction App() {\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n}\r\n```\r\n\r\nThe reducer function is simply a function that contains a set of conditions and returns something depending on that condition. The best way to accomplish it is by using the `switch` statement but no one is stopping from using something like `if-else` instead.\r\n\r\nA simple implementation of `useReducer` with example of counter:\r\n\r\n```js\r\nconst initialState = { count: 0 };\r\n\r\nfunction reducer(state, action) {\r\n  switch (action.type) {\r\n    case \"increment\":\r\n      return { count: state.count + 1 };\r\n    case \"decrement\":\r\n      return { count: state.count - 1 };\r\n    default:\r\n      throw new Error();\r\n  }\r\n}\r\n\r\nfunction Counter() {\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n  return (\r\n    \u003C>\r\n      Count: {state.count}\r\n      \u003Cbutton onClick={() => dispatch({ type: \"decrement\" })}>-\u003C/button>\r\n      \u003Cbutton onClick={() => dispatch({ type: \"increment\" })}>+\u003C/button>\r\n    \u003C/>\r\n  );\r\n}\r\n```\r\n\r\nThe idea here is simple. Whenever the `dispatch` function is fired, it dispatches its argument to the reducer function. The reducer function matches that with predefined conditions and return a new state. This way, more complex states can be managed. You could possibly emulate this using the previous state pattern. Of course, that will be more complex.\r\n\r\nWith that, I will wind up this article. If you made it till here, congrats.","src/content/blog/a-complete-guide-to-usestate-hook.mdx","f9fd7b5a5e291ce7","a-complete-guide-to-usestate-hook.mdx",true,"projects",["Map",28,29,54,55,76,77,100,101,124,125],"golden-pen-award",{"id":28,"data":30,"body":41,"filePath":42,"digest":43,"rendered":44,"legacyId":53},{"title":31,"description":32,"imageUrl":33,"url":34,"tags":35,"publishedAt":40},"Golden Pen Award","The Golden Pen Award aims to celebrate the most influential literary works in the Arab world, supporting writers who enrich Arabic literature with their unique contributions.","/assets/golden_pen.png","https://www.goldenpenaward.com/ar",[36,37,38,39],"Next.js","Typescript","TailwindCSS","Strapi","2024-01-01","Most of the work associated with the Golden Pen Award is currently confidential or managed under NDA. This page serves as a placeholder for the project details.","src/content/projects/golden-pen-award.md","9b0f872dd895fa14",{"html":45,"metadata":46},"\u003Cp>Most of the work associated with the Golden Pen Award is currently confidential or managed under NDA. This page serves as a placeholder for the project details.\u003C/p>",{"headings":47,"localImagePaths":48,"remoteImagePaths":49,"frontmatter":50,"imagePaths":52},[],[],[],{"title":31,"description":32,"imageUrl":33,"url":34,"tags":51,"publishedAt":40},[36,37,38,39],[],"golden-pen-award.md","joy-awards",{"id":54,"data":56,"body":63,"filePath":64,"digest":65,"rendered":66,"legacyId":75},{"title":57,"description":58,"imageUrl":59,"url":60,"tags":61,"publishedAt":62},"Joy Awards","The Joy Awards is an annual ceremony in Riyadh, Saudi Arabia that honors the artistic achievements of Arab celebrities.","/assets/joy_awards.png","https://joyawards.sa/en",[36,37,38,39],"2024-02-01","Details about the Joy Awards project will be added here.","src/content/projects/joy-awards.md","bb1be3d4f85288ac",{"html":67,"metadata":68},"\u003Cp>Details about the Joy Awards project will be added here.\u003C/p>",{"headings":69,"localImagePaths":70,"remoteImagePaths":71,"frontmatter":72,"imagePaths":74},[],[],[],{"title":57,"description":58,"imageUrl":59,"url":60,"tags":73,"publishedAt":62},[36,37,38,39],[],"joy-awards.md","saudi-grand-prix",{"id":76,"data":78,"body":87,"filePath":88,"digest":89,"rendered":90,"legacyId":99},{"title":79,"description":80,"imageUrl":81,"url":82,"tags":83,"publishedAt":86},"Saudi Arabian Grand Prix","The Saudi Arabian Grand Prix is a Formula One motor racing event which took place for the first time in 2021. The inaugural edition of the race was held in Jeddah, in Saudi Arabia.","/assets/saudi_grand_prix.png","https://saudiarabiangp.com/en",[36,37,38,84,85],"Contentful","GraphQL","2023-03-01","Details about the Saudi Arabian Grand Prix project will be added here.","src/content/projects/saudi-grand-prix.md","544175e020c56789",{"html":91,"metadata":92},"\u003Cp>Details about the Saudi Arabian Grand Prix project will be added here.\u003C/p>",{"headings":93,"localImagePaths":94,"remoteImagePaths":95,"frontmatter":96,"imagePaths":98},[],[],[],{"title":79,"description":80,"imageUrl":81,"url":82,"tags":97,"publishedAt":86},[36,37,38,84,85],[],"saudi-grand-prix.md","people-supported-intelligence",{"id":100,"data":102,"body":111,"filePath":112,"digest":113,"rendered":114,"legacyId":123},{"title":103,"description":104,"imageUrl":105,"url":106,"tags":107,"publishedAt":110},"People Supported Intelligence","People Supported Intelligence (PSi) is a platform for a new type of online dialogue that fosters consensus from opposing views.","/assets/psi.png","https://psi.tech/",[36,37,38,108,85,109],"Hasura","Figma","2022-01-01","Details about the People Supported Intelligence project will be added here.","src/content/projects/people-supported-intelligence.md","7059febdd39e8581",{"html":115,"metadata":116},"\u003Cp>Details about the People Supported Intelligence project will be added here.\u003C/p>",{"headings":117,"localImagePaths":118,"remoteImagePaths":119,"frontmatter":120,"imagePaths":122},[],[],[],{"title":103,"description":104,"imageUrl":105,"url":106,"tags":121,"publishedAt":110},[36,37,38,108,85,109],[],"people-supported-intelligence.md","worx-remotely",{"id":124,"data":126,"body":133,"filePath":134,"digest":135,"rendered":136,"legacyId":145},{"title":127,"description":128,"imageUrl":129,"url":130,"tags":131,"publishedAt":132},"Worx Remotely","All in one digital workplace for enterprise productivity.","/assets/worx.png","https://worxsquad.com/",[36,37,38,108,85,109],"2021-01-01","Details about the Worx Remotely project will be added here.","src/content/projects/worx-remotely.md","51a770545c7fc903",{"html":137,"metadata":138},"\u003Cp>Details about the Worx Remotely project will be added here.\u003C/p>",{"headings":139,"localImagePaths":140,"remoteImagePaths":141,"frontmatter":142,"imagePaths":144},[],[],[],{"title":127,"description":128,"imageUrl":129,"url":130,"tags":143,"publishedAt":132},[36,37,38,108,85,109],[],"worx-remotely.md"]